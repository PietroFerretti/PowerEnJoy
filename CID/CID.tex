\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=true,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\usepackage{tabularx}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{svg}
\usepackage{float}
\usepackage{titling}
\renewcommand{\arraystretch}{1.4}
\newcommand{\code}[1]{\texttt{#1}}
\usepackage{listings}
\usepackage{color}
\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc

\lstset{language=Java,
	basicstyle=\ttfamily\small,
	xleftmargin=0cm,
	keywordstyle=\color{javapurple}\bfseries,
	stringstyle=\color{javared},
	commentstyle=\color{javagreen},
	morecomment=[s][\color{javadocblue}]{/**}{*/},
	numbers=left,
	numberstyle=\tiny\color{black},
	stepnumber=1,
	numbersep=10pt,
	tabsize=4,
	showspaces=false,
	showstringspaces=false,
	linewidth=13cm,
	breaklines=true
	}

\pretitle{%
	\begin{center}
		\LARGE
		\includegraphics[width=250pt]{../other/Logo_blu.png}\\[\bigskipamount]~\\[\bigskipamount]
	}
\posttitle{\end{center}}

\begin{document}

\title{Politecnico di Milano\\
 A.A. 2016–2017 \\
Software Engineering 2: “PowerEnJoy” \\
\emph{\textbf{Code Inspection Document}}}

\author{Pietro Ferretti, Nicole Gervasoni, Danilo Labanca}
\date{February 5, 2017}
\maketitle

\newpage

\tableofcontents{}

\newpage

\section{Assigned Class}
% <state the namespace pattern and name of the classes that were assigned to you.>

\texttt{apache-ofbiz-16.11.01/framework/service/\\
\hspace*{1cm}src/main/java/org/apache/ofbiz/service/job/JobManager.java}

\section{Functional Role}% of assigned set of classes: <elaborate on the functional role you have identified for the class cluster that was assigned to you, also, elaborate on how you managed to understand this role and provide the necessary evidence, e.g., javadoc, diagrams, etc.>

\subsection{Service Engine}
Introduction

Services are independent pieces of logic which when placed together process many different types of business requirements. Services can be of many different types: Workflow, Rules, Java, SOAP, BeanShell, etc. A service with the type Java is much like an event where it is a static method, however with the Services Framework we do not limit to web based applications. Services require input parameters to be in a Map and the results are returned in a Map as well. This is nice since a Map can be serialized and stored or passed via HTTP (SOAP).

Services are defined through the Service Definition and are assigned to a specific Service Engine. Each Service Engine is responsible for invoking the defined service in an appropriate way. Since services are not tied to web based applications this allows services to run when there is no response object available. This allows services to be scheduled to run at specific times to run in the background via the Job Scheduler.

Services have the ability to call other services. So, chaining small services together to accomplish a larger task makes reusing existing services much easier.

Services which are declared in a component (service-resource in ofbiz-component.xml file) are reachable from anywhere in OFBiz, and even outside using the export feature. Though this possibility is not commonly used (no examples OOTB), it's also possible to create services which are specific to an application: restricted to be available only in that application. For that, you put the service definition and implementation files under the WEB-INF directory. You can also override a service by using the same name down in the deployment context (which is first framework, then themes, then applications, then specialpurpose, then hot-deploy). This is handy, but beware if not wanted...

When used in a web application services are available to web events, which allow events to stay small and reuse existing logic in the Services Framework. Also, services can be defined as 'exportable' which means they are allowed to be accessed by outside parties. Currently there is a SOAP EventHandler which allows services to be made available via SOAP. Other forms of remote invocation may be added to the framework in the future.

\subsection{Package: Job etc.}
Job Scheduler

The overhauled job scheduler is now integrated with the services framework. This is the most appropriate place for a scheduler. Since it cannot be guarantee that an HttpServletRequest and HttpServletResponse object will be available when a job is ready to run, it does not make sense to integrate with the web controller. Plus, this feature is most useful when not limited to web environments.

The scheduler is a multi-threaded component with a single thread used for job managing/scheduling and separate threads used for invocation of each service. When a job is scheduled to run, the scheduler will call the service dispatcher associated with the job to invoke the service in its own thread. This will prevent long or time consuming jobs from slowing down other jobs in the queue.

The scheduler now supports the iCalendar rule structure for recurrence. The jobs are no longer stored in an XML file and each is part of a ServiceDispatcher. There is one Job Scheduler for each ServiceDispatcher (which means there is only one per GenericDelegator as well).

How it works:

The best usage example of the scheduler is an asynchronous service call. When an asynchronous service is invoked, it is passed to the Job Scheduler to be queued to run. A recurrence entry is created (RecurrenceInfo and RecurrenceRule entities are created), the job is stored, (JobSandbox entity is created) and the context (Map) is serialized and stored (RuntimeData entity is created). The scheduler then adds the job to the top of the list of scheduled jobs (asynchronous services do not have any delay time) and invoked.

Jobs are no longer defined in an XML file. This has been moved to the JobSandbox entity. There is a web based client in planning for adding predefined jobs to the queue, but currently the entities will have to be created by hand.

\subsection{Class: Job Manager}
\paragraph{Javadoc}

\begin{lstlisting}

/**
* Job manager. The job manager queues and manages jobs. Client code can queue a job to be run immediately
* by calling the runJob({@link #runJob(Job)}) method, or schedule a job to be run later by calling the
* {@link #schedule(String, String, String, Map, long, int, int, int, long, int)} method.
* Scheduled jobs are persisted in the JobSandbox entity.
* <p>A scheduled job's start time is an approximation - the actual start time will depend
* on the job manager/job poller configuration (poll interval) and the load on the server.
* Scheduled jobs might be rescheduled if the server is busy. Therefore, applications
* requiring a precise job start time should use a different mechanism to schedule the job.</p>
*/

\end{lstlisting}

The job manager queues and manages jobs. 

Client code can queue a job to be run immediately by calling the runJob method, or schedule a job to be run later by calling the schedule method. 

Scheduled jobs are persisted in the JobSandbox entity. A scheduled job's start time is an approximation - the actual start time will depend on the job manager/job poller configuration (poll interval) and the load on the server.
Scheduled jobs might be rescheduled if the server is busy. Therefore, applications requiring a precise job start time should use a different mechanism to schedule the job.

\section{List of Issues} % found by applying the checklist: <report the classes/code fragments that do not fulfill some points in the check list. Explain which point is not fulfilled and why.>
% what are we gonna do
We list here all the issues we have found in the code
all the issues corresponding to each point in the checklist


\subsection{Naming Conventions}

\paragraph{1. Meaningful Names}\\
Ok. All names are meaningful.

\paragraph{2. One-character variables}\\
Ok, there are no one-character variables.

\paragraph{3. Class names}\\
Ok, every class name is in mixed case and properly capitalized.

\paragraph{4. Interface names}\\
OK. No interfaces are declared.
(se ce ne sono) every interface used by the code is in mixed case and properly capitalized.

\paragraph{5. Method names}\\
Ok. Every method name is a verb and every method name is camelCase and properly capitalized.

\paragraph{6. Class variables}\\
Ok. Every class variable is in mixed case and properly capitalized.

\paragraph{7. Constants}\\
The field \begin{lstlisting} private static final module \end{lstlisting} and \begin{lstlisting} private static final instanceId \end{lstlisting} are immutable, 
so they can be considered as constant; they should be capitalized. Instead \begin{lstlisting} private static final registeredManagers \end{lstlisting} is fine because it's mutable

%https://stackoverflow.com/a/30789385

\subsection{Indentation}\\

\paragraph{8. Number of spaces}
Ok, the code is consistently indented with 4 spaces.

\paragraph{9. No tabs for indentation}
Ok. No tabs are used to indent the code.

\subsection{Braces}

\paragraph{10. Consistent bracing style}
Ok.
The code is consistently braced following the \textit{"Kernighan and Ritchie"} style.

\paragraph{11. One-line statements bracing}
No there are:
\begin{itemize}
	\item \begin{lstlisting} if (Debug.infoOn()) Debug.logInfo("Scheduling Job : " + job, module); \end{lstlisting} on line 326;
	\item \begin{lstlisting} if (Debug.infoOn())
                Debug.logInfo("-- " + rescheduled + " jobs re-scheduled", module); \end{lstlisting} on line 351-352;
    \item \begin{lstlisting} if (Debug.infoOn())
                Debug.logInfo("No crashed jobs to re-schedule", module); \end{lstlisting} on line 354-355;
\end{itemize}

\subsection{File Organization}
\paragraph{12. Blank lines as separation}
Ok.
Blank lines are present between each method, around imports and variable declarations.
Most of the methods also begin with a Javadoc.

\paragraph{13. Where practical, line length under 80 characters}
NOPE
righe 73, 74, 89, 126, 147, 150, 154, 156, 161, 182, 186-190, 195, 198, 201, 
A great number of lines exceed 80 characters

\paragraph{14. Line length always under 120 characters}
NEPPURE
righe 74, 186, 198, 217, 221, 222, 261-264, 273, 311, 315, 317, 387, 409, 429, 453, 498, 543, 560, 561
le dichiarazioni dei metodi sono lunghissime e wrappate poco

\subsection{Wrapping Lines}
\paragraph{15. Line breaks after commas and operators}
NO
riga 152, la virgola dovrebbe stare sopra % e chissenefrega

\paragraph{16. Higher-level breaks are used}
 Ok. There aren't any lyne break with operators

\paragraph{17. Statements are aligned to previous ones}
Ok. All statements are aligned to previous ones.

\subsection{Comments}

\paragraph{18. Comments use}
The method 
\begin{lstlisting} 
	public synchronized void reloadCrashedJobs() 
\end{lstlisting}

 on line 305 is not commented and so it isn't easy to understand. \\
The rest of the code is well commented.

\paragraph{19. Commented out code}
There aren't lines of code hidden in block of comments in the source code.

\subsection{Java Source Files}
\paragraph{20. Single public class or interface}
Ok.
Job manager is the only public class declared in the file.
There are no other classes.

\paragraph{21. The public class is the first class in the file}
Ok.
Job manager is the only public class declared in the file.
There are no other classes.

\paragraph{22. External program interfaces are consistent with the Javadoc}
Ok
abbiamo vari metodi pubblici:
getter:
- getDelegator
- getDispatcher
- getInstance
- getPoolState
poi altre robe
- isAvailable
- reloadCrashedJobs
- runJob
- schedule di tutti i tipi

la Javadoc parla di runJob e schedule

\paragraph{23. The Javadoc is complete}
NO.
\begin{itemize}
	\item No javadoc for 'module'! line 71
	\item No javadoc for 'instanceId'! line 71
	\item No javadoc for reloadCrashedJob!! line 304
	\item Missing @return tag on getInstance, line 88
	\item Missing @return tag on getDelegator, line 119
	\item Missing @return tag on getDispatcher, line 124
	\item Missing @param tag for 'limit' on poll, line 174
	\item Missing @return tag on poll, line 174
	\item Missing @param tag for 'job' on runJob, line 363
	\item Missing @throws tag for 'JobManagerException' on runJob, line 363
	\item Missing @throws tag for 'JobManagerException' on schedule, line 386, 408, 428, 453, 469, 498, 543
\end{itemize}

assertIsRunning, getRunPools sono private quindi non hanno necessariamente bisogno di javadoc

\subsection{Package and Import Statements}
\paragraph{24. Package statements are first, import statements second}
Ok.
One package statements.
All import statements immediately follow.

\subsection{Class and Interface Declarations}
\paragraph{25. The class declarations should follow a specific order}
- javadoc ok
- class declaration ok
- altri commenti /
- static variables ok
 - public ok
 - private ok
- normal variables 
- constructors
- methods

no, abbiamo variabili statiche, poi un po' di metodi statici, poi variabili normali, poi costruttori (getInstance è un costruttore), setter e getter poi un metodo statico (ma private!!)


\paragraph{26. Methods are grouped by functionality}
Ok

assertIsRunning
getInstance
shutDown

getDelegator
getDispatcher
getPoolState

isAvailable
getRunPools
pool
reloadCrashedJobs
runJob
schedule

\paragraph{27. The code is free of duplicates, long methods, big classes, breaking encapsulation, and coupling and cohesion are adequate}
small class
duplicates? no
short methods
no breaking encapsulation

low/loose coupling -> ci sono un sacco di delegator e dispatcher
high cohesion -> tutti i metodi servono a runnare/queuare jobs

\subsection{Initialization and Declarations}

\paragraph{28. Visibility}
All variables and class members are of the correct type and have the proper visibility.
In line 305 the method \begin{lstlisting} 
public synchronized void reloadCrashedJobs()
\end{lstlisting} could be stated as protected.

\paragraph{29. Proper scope.} 
OK. All variables are declared in the proper scope

\paragraph{30. New objects.} 
OK. Each time a new object is desired the proper constructor is called

\paragraph{31. All object references are initialized before use.} 
OK. All reference are initialized before any object uses it. 

\paragraph{32. Variables initialization.} 
OK. All variables are initialized where they are declared, unless dependent upon a computation.

\paragraph{33. Declarations.} OK. Each declaration appear at the beginning of blocks.

\subsection{Method Calls}

\paragraph{34. Correct orders parameters}

Sembra tutto bene

\paragraph{35. The called method is the right method}

Sembra di si

\paragraph{36. The returned value from the method is used properly}

Me pare de si


\subsection{Arrays}
\paragraph{37. No off-by-one errors in array indexing}
Ok.
The only indexing is with foreach, no off-by-one errors.

\paragraph{38. No out-of-bounds indexes}
Ok.
No number indexing.

\paragraph{39. Constructors are called when a new array item is desired}
Ok.
quali nuovi array? non ce ne sono

\subsection{Object Comparison}
\paragraph{40. Objects are compared with equals}
Ok.
There are no object comparisons.

\subsection{Output Format}
\paragraph{41. Displayed output is free of spelling and grammatical errors}
riga 156:
Debug.logWarning(e, "Exception thrown while check lock on JobManager : " + instanceId, module);
dovrebbe essere "while checking"

riga 182:
Debug.logWarning("Unable to locate DispatchContext object; not running job!", module);
dovrebbe essere "job:", come negli altri log di debug


\paragraph{42. Error messages are comprehensive and useful}
si

\paragraph{43. Output is formatted correctly in terms of line breaks and spacing}
No line breaks in outputs
Some debug outputs don't have a trailing space ~

\subsection{Computation, Comparisons and Assignments}
\paragraph{44."Brutish programming".}the  avoids
OK. The implementation avoids brute force solutions; the code is simple and concise.

\paragraph{45. Operator precedence and parenthesizing.}
OK. Computation/evaluation of operator precedence and parentheses is in the proper order.
 
\paragraph{46. The liberal use of parenthesis is used to avoid operator precedence problems.}
OK. There aren't any parenthesis used in an appropriate way.

\paragraph{47. All denominators of a division are prevented from being zero.}
OK. There are no division.

\paragraph{48. Integer arithmetic, especially division, are used appropriately to avoid causing unexpected truncation/rounding.}
OK. Integer arithmetic is used only to increment variable.

\paragraph{49. Comparison and Boolean operators are correct.}
OK.

\paragraph{50. Throw-catch expressions.}
OK. The error condition is always legitimate

\paragraph{51. The code is free of any implicit type conversions.}
OK. The code is free 
\subsection{Exceptions}

\paragraph{52. Relevant exceptions are caught.}
OK.
\paragraph{53. The appropriate action is taken for each catch block.}
OK. There are two general
\begin{lstlisting}
catch (Throwable t)
\end{lstlisting} in order to guarantee a working jobPoller even when a database connection is not available.

\subsection{Flow of Control}
\paragraph{54. All switch cases are addressed with a break}
Ok, no switch statements.

\paragraph{55. All switch statements have a default branch}
Ok, no switch statements.

\paragraph{56. All loops are correctly formed, with appropriate initialization, increments and termination expressions}
Ok.
All for loops are foreach, everything is fine.
The while loop at line 219:
GenericValue jobValue = jobsIterator.next();
while (jobValue != null) {
jobValue = jobIterator.next();
tutto ok, l'iteratore va avanti finch non finiscono i valori, poi esce dal while
while a riga 275 uguale

a posto

\subsection{Files}
\paragraph{}
The JobManager class does not have to handle file.

\section{Other Problems} % you have highlighted: <list here all the parts
%of code that you think create or may create a bug and explain why.>
alla riga 576:
viene chiamato new Long(0), che è meno efficiente di valueOf(0)
Using new Integer(int) is guaranteed to always result in a new object whereas Integer.valueOf(int) allows caching of values to be done by the compiler, class library, or JVM. Using of cached values avoids object allocation and the code will be faster.
Values between -128 and 127 are guaranteed to have corresponding cached instances and using valueOf is approximately 3.5 times faster than using constructor. For values outside the constant range the performance of both styles is the same

se ci sono tante richieste sostituirlo migliorerebbe le prestazioni
ma comunque problema minore, basso impatto


No other problems

\section{Effort Spent}
\begin{itemize}
	\item{Pietro Ferretti:  hours of work}
	\item{Nicole Gervasoni:  hours of work}
	\item{Danilo Labanca:  hours of work}
\end{itemize}


\section{Revisions}

\subsection{Changelog}
\begin{itemize}
	\item{CID v1.0, published on February 5, 2017}
\end{itemize}
\end{document}
